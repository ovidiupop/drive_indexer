

def prepareQrcFile():
    current_directory = str(pathlib.Path(__file__).parent.absolute())
    images_folder = current_directory + '/../images'
    resource_file_path = current_directory + '/../resources.qrc'
    path = QtCore.QDir(images_folder)
    with open(resource_file_path, 'w') as f:
        f.write('<RCC>\n')
        recursiveFolders(path, f, True, '')
        f.write('\t</qresource">\n')
        f.write('</RCC>')

# working but not perfect
def recursiveFolders(path, f, start=True, last_folder_name=''):
    directory = QtCore.QDir(path)
    directory.setFilter(directory.filter() | QtCore.QDir.NoDotAndDotDot | QtCore.QDir.NoSymLinks)
    last_folder_name = ''
    occurences_of_slash = 0
    prefix_tabs = ''
    for entry in directory.entryInfoList():
        if entry.isDir() and start:
            last_folder_name += '/' + entry.fileName()
            occurences_of_slash = last_folder_name.count('/')
            prefix_tabs = '\t' * occurences_of_slash
            f.write(f'{prefix_tabs}<qresource prefix="{last_folder_name}">\n')
            start = False
        if entry.isFile():
            file_tabs = '\t' * (occurences_of_slash + 1)
            f.write(f'{file_tabs}<file>{entry.fileName()}</file>\n')
        if entry.isDir():
            recursiveFolders(entry.filePath(), f, True, last_folder_name)


# def getIcon(item, size=24):
#     current_directory = str(pathlib.Path(__file__).parent.absolute())
#     if item in icons_map.keys():
#         name = icons_map[item]
#         path = current_directory + '/../images/icons/' + name + '.png'
#         print(item, path, exists(path))
#         icon = QtGui.QIcon(path)
#         return icon.pixmap(size)
        # else:
        #     mime = mimetypes.types_map
        #     ext = '.'+item
        #     if ext in mime.keys():
        #         name = mime[ext].replace('/', '-')
        #         icon = QtGui.QIcon.fromTheme(name)
        #         if not icon.isNull():
        #             return icon.pixmap(size)
        #         else:
        #             a = QMimeDatabase().allMimeTypes()
        #             for mime in a:
        #                 if mime.name() == 'text/' + item or mime.name() == 'application/x-' + item:
        #                     name = mime.name().replace('/', '-')
        #                     icon = QtGui.QIcon.fromTheme(name)
        #                     if not icon.isNull():
        #                         return icon.pixmap(size)






    # def preselectFavoriteExtensions(self, ext_lists):
    #     ext_lists = [self.settings_extensions_list]
    #     extensions_db = gdb.getAll('extensions')
    #     selected_extensions = gdb.preselectedExtensions()
    #     self.entry = QtGui.QStandardItemModel()
    #     for idx, ex in enumerate(extensions_db):
    #         extension = ex['extension']
    #         ext = QtGui.QStandardItem(extension)
    #         self.entry.appendRow(ext)
    #         # select preselected items
    #         if extension in selected_extensions:
    #             ix = self.entry.index(idx, 0)
    #             sm = self.settings_extensions_list.selectionModel()
    #             sm.select(ix, QtCore.QItemSelectionModel.Select)



    # def setPreferredExtension(self):
    #     selected_ex = self.settings_extensions_list.selectedIndexes()
    #     extensions = []
    #     if len(selected_ex):
    #         extensions = []
    #         for extension in selected_ex:
    #             extensions.append(extension.data())
    #     if extensions:
    #         if gdb.setPreferredExtensions(extensions):
    #             QtWidgets.QMessageBox.information(None, 'Preferred set', 'Preferred extensions set!')




def preselectedExtensions() -> list:
    """
    :return:
    DEPRECATED
    """
    selected = []
    query = QtSql.QSqlQuery("SELECT extension FROM extensions where selected=1 ORDER BY id")
    while query.next():
        selected.append(query.value('extension'))
    query.clear()
    return selected



def setPreferredExtensions(extensions: list) -> bool:
    query = QtSql.QSqlQuery()
    query.prepare("UPDATE extensions SET selected=0 WHERE 1")
    if query.exec():
        placeholder = ','.join("?" * len(extensions))
        query.prepare('UPDATE extensions SET selected=1 WHERE extension IN (%s)' % placeholder)
        for binder in extensions:
            query.addBindValue(str(binder))
        ret = query.exec()
        query.clear()
        return ret


# def preselectFavoriteExtensions(self):
#     ext_lists = [self.settings_extensions_list]
#     extensions_db = gdb.getAll('extensions')
#     selected_extensions = gdb.preselectedExtensions()
#     self.entry = QtGui.QStandardItemModel()
#     for idx, ex in enumerate(extensions_db):
#         extension = ex['extension']
#         ext = QtGui.QStandardItem(extension)
#         self.entry.appendRow(ext)
#         # select preselected items
#         if extension in selected_extensions:
#             ix = self.entry.index(idx, 0)
#             sm = self.settings_extensions_list.selectionModel()
#             sm.select(ix, QtCore.QItemSelectionModel.Select)



    # unused (root)
    def backToNormalUser(self):
        cmd = f'su - {self.normal_user}'
        os.system(cmd)

    # unused (root)
    def connectAsRoot(self):
        # *nix system
        if os.name == 'posix' and not os.getuid() == 0:
            # save actual user
            self.normal_user = getActiveUser()
            print('not logged as root')
            passwd, ok = QInputDialog.getText(None, 'Root Password', 'Please enter root password:',
                                              QtWidgets.QLineEdit.Password)
            if ok:
                answer = os.system("echo '" + passwd + "' |sudo -S echo 'checking passwd'  ")
                while answer != 0:
                    passwd, ok = QInputDialog.getText(None, 'Root Password', 'Wrong Password!\nTry again!',
                                                      QtWidgets.QLineEdit.Password)
                    if ok:
                        answer = os.system("echo '" + passwd + "' |sudo -S echo 'checking passwd'  ")
                    else:
                        ok = False
                        break
                if ok:
                    print('You are root now!')
                    return True
            print("Loging as root failed!")
            return False
        else:
            print("Not unix or already logged")
            return True




def getActiveUser():
    return pwd.getpwuid(os.getuid())[0]


def mountedDrivesOld():
    disks = []
    s = subprocess.Popen(f'lsblk --nodeps -o type,name,serial,size,model', shell=True, stdin=None,
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    lines = s.stdout.readlines()
    if lines:
        for line in lines:
            line = line.decode('ascii').strip()
            x = line.split(' ')
            while "" in x:
                x.remove("")
            if x[0] == 'disk':
                disk = {'mounted': x[1], 'name': x[4], 'serial': x[2], 'size': sizeToGb(x[3])}
                disks.append(disk)
    setActiveDriveDB(disks)
    return disks




# df /home/matricks/aacustom/Muzica/ => /dev/sda4      316212352 204173148  95906752  69% /home/matricks/aacustom
# inxi -Dxx
# lsblk -l -o type,fstype,kname,size,hotplug,serial,path,mountpoint,vendor,model | grep -e disk -e part
def mountedDrives():
    if 'linux' in sys.platform:
        dpart = {}
        disk_parts = subprocess.Popen(f'lsblk -l -o type,path,mountpoint | grep -e part', shell=True, stdin=None,
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        lines_disk_parts = disk_parts.stdout.readlines()
        if lines_disk_parts:
            for line_partition in lines_disk_parts:
                line_partition = line_partition.decode('ascii').strip()
                parts = line_partition.split(' ')
                while "" in parts:
                    parts.remove("")
                parent = parts[1].rstrip('0123456789').strip()
                if len(parts) > 2:
                    mount_point = parts[2]
                    if parent in dpart:
                        dpart[parent].append(mount_point)
                    else:
                        dpart[parent] = [mount_point]

        # dpart result is {'/dev/sda': ['/boot/efi', '/', '/home', '/home/matricks/aacustom'], '/dev/sdb': ['/home/matricks/aacustom/myoneterra'], '/dev/sdc': ['/home/matricks/aacustom/mybook']}
        disks = []
        drives = subprocess.Popen(f'lsblk -l -o type,serial,path,size,hotplug,model,vendor | grep -e disk', shell=True, stdin=None,
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        lines_drives = drives.stdout.readlines()
        if lines_drives:
            for line_drive in lines_drives:
                line_drive = line_drive.decode('ascii').strip()
                x = line_drive.split(' ')
                while "" in x:
                    x.remove("")
                if x[0] == 'disk':
                    disk = {'serial': x[1], 'path': x[2], 'size': sizeToGb(x[3]), 'hotplug': x[4], 'name': x[5], 'vendor': x[6]}
                    disks.append(disk)
                else:  # is partition
                    pass
        if disks:
            setActiveDriveDB(disks)
        return disks
        # return this
        # [{'serial': 'S3Z2NB2KA50740N', 'path': '/dev/sda', 'size': 465.8, 'hotplug': '0', 'name': 'Samsung_SSD_860_EVO_500GB', 'vendor': 'ATA'},
        # {'serial': 'Z9AX3YM7', 'path': '/dev/sdc', 'size': 931.5, 'hotplug': '1', 'name': 'ST1000DM010-2EP102', 'vendor': 'ST1000DM'},
        # {'serial': 'WD-WMC4N0404141', 'path': '/dev/sdd', 'size': 2700.0, 'hotplug': '1', 'name': 'WDC_WD30EZRX-00D8PB0', 'vendor': 'WDC'},
        # {'serial': '4990779F50C0', 'path': '/dev/sde', 'size': 931.5, 'hotplug': '1', 'name': 'XPG_EX500', 'vendor': 'ADATA'}]
